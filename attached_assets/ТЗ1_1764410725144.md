# РЕКОМЕНДАЦИИ ПО УЛУЧШЕНИЮ
## E-commerce платформа "ЭкоМаркет"

Дата: 29 ноября 2025

---

## КРИТИЧЕСКИЕ ПРОБЛЕМЫ (исправить немедленно)

### 1. Path Traversal при удалении изображений

**Проблема:**
```typescript
// server/ImagePipeline.ts:244-254
async deleteImage(filename: string): Promise<void> {
  const filePath = path.join(this.uploadsDir, filename);
  await fs.unlink(filePath);
}
```
Атакующий может передать `../../../../etc/passwd` и удалить системные файлы.

**Решение:**
```typescript
async deleteImage(filename: string): Promise<void> {
  // Валидация filename
  if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
    throw new Error('Invalid filename');
  }
  
  const filePath = path.join(this.uploadsDir, filename);
  
  // Проверка, что путь находится внутри uploadsDir
  const resolvedPath = path.resolve(filePath);
  const resolvedUploadsDir = path.resolve(this.uploadsDir);
  if (!resolvedPath.startsWith(resolvedUploadsDir)) {
    throw new Error('Path traversal detected');
  }
  
  await fs.unlink(filePath);
}
```

---

### 2. Race Condition при использовании промокодов

**Проблема:**
```typescript
// server/promocodes.ts:85-108
export async function applyPromocode(...) {
  const [promocode] = await db.select()...
  if (promocode.type === "single_use") {
    await db.delete(promocodes)... // Не атомарная операция
  }
}
```
Два одновременных запроса могут использовать один одноразовый промокод дважды.

**Решение:**
```typescript
export async function applyPromocode(
  promocodeId: string,
  userId: string,
  orderId: string
): Promise<void> {
  await db.transaction(async (tx) => {
    const [promocode] = await tx
      .select()
      .from(promocodes)
      .where(eq(promocodes.id, promocodeId))
      .for('update') // Блокируем строку
      .limit(1);
    
    if (!promocode) {
      throw new Error("Промокод не найден");
    }
    
    if (promocode.type === "single_use") {
      const result = await tx
        .delete(promocodes)
        .where(eq(promocodes.id, promocodeId))
        .returning();
      
      if (result.length === 0) {
        throw new Error("Промокод уже использован");
      }
    } else if (promocode.type === "temporary") {
      await tx.insert(promocodeUsage).values({
        promocodeId,
        userId,
        orderId,
      });
    }
  });
}
```

---

### 3. Inventory Overselling при создании заказа

**Проблема:**
Между проверкой наличия товара и созданием заказа товар может быть распродан другими запросами.

**Решение:**
```typescript
// В routes.ts - обернуть в транзакцию с pessimistic locking
await db.transaction(async (tx) => {
  // Блокируем товары для обновления
  const products = await tx
    .select()
    .from(products)
    .where(inArray(products.id, cartItems.map(i => i.productId)))
    .for('update');
  
  // Проверяем наличие
  for (const item of cartItems) {
    const product = products.find(p => p.id === item.productId);
    if (!product || product.stockQuantity < item.quantity) {
      throw new Error(`Товар ${product?.name} недоступен в нужном количестве`);
    }
  }
  
  // Обновляем количество
  for (const item of cartItems) {
    await tx
      .update(products)
      .set({
        stockQuantity: sql`${products.stockQuantity} - ${item.quantity}`,
        updatedAt: new Date()
      })
      .where(eq(products.id, item.productId));
  }
  
  // Создаем заказ
  const [order] = await tx.insert(orders).values({...}).returning();
  
  return order;
});
```

---

### 4. WebSocket Memory Leak в Rate Limiting

**Проблема:**
```typescript
// server/routes.ts:109-110
const connectionRateLimits = new Map<string, { count: number; resetAt: number }>();
const messageRateLimits = new Map<string, { count: number; resetAt: number }>();
```
Maps растут бесконечно без очистки старых записей.

**Решение:**
```typescript
const connectionRateLimits = new Map<string, { count: number; resetAt: number }>();
const messageRateLimits = new Map<string, { count: number; resetAt: number }>();

// Периодическая очистка устаревших записей
setInterval(() => {
  const now = Date.now();
  
  // Очистка connection rate limits
  for (const [key, value] of connectionRateLimits.entries()) {
    if (now > value.resetAt) {
      connectionRateLimits.delete(key);
    }
  }
  
  // Очистка message rate limits
  for (const [key, value] of messageRateLimits.entries()) {
    if (now > value.resetAt) {
      messageRateLimits.delete(key);
    }
  }
}, 60000); // Каждую минуту
```

---

### 5. Незашифрованные платежные токены YooKassa

**Проблема:**
```typescript
// shared/schema.ts
yukassaPaymentToken: text("yukassa_payment_token").notNull()
```
Платежные токены хранятся в открытом виде, что нарушает PCI DSS.

**Решение:**
```typescript
// 1. Установить библиотеку шифрования
npm install @aws-crypto/client-node

// 2. Создать утилиты шифрования
// server/utils/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex'); // 32 байта

export function encryptToken(token: string): string {
  const iv = randomBytes(16);
  const cipher = createCipheriv(ALGORITHM, KEY, iv);
  
  let encrypted = cipher.update(token, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}

export function decryptToken(encryptedData: string): string {
  const [ivHex, authTagHex, encrypted] = encryptedData.split(':');
  
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  const decipher = createDecipheriv(ALGORITHM, KEY, iv);
  
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

// 3. Использовать при сохранении/извлечении токенов
const encryptedToken = encryptToken(paymentToken);
await db.insert(orders).values({
  ...orderData,
  yukassaPaymentToken: encryptedToken
});

// При получении
const decryptedToken = decryptToken(order.yukassaPaymentToken);
```

---

### 6. Отсутствие тестов

**Проблема:**
Полное отсутствие unit, integration и E2E тестов.

**Решение:**
```bash
# 1. Установить зависимости
npm install -D vitest @testing-library/react @testing-library/jest-dom happy-dom
npm install -D supertest @types/supertest

# 2. Создать конфигурацию vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'happy-dom',
    setupFiles: ['./test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: ['node_modules/', 'test/']
    }
  }
});

# 3. Создать тесты для критичных функций
// server/promocodes.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { validatePromocode, applyPromocode } from './promocodes';

describe('Promocode System', () => {
  it('should prevent double usage of single_use promocode', async () => {
    const promocodeId = 'test-promo-id';
    const userId = 'user-1';
    
    await applyPromocode(promocodeId, userId, 'order-1');
    
    await expect(
      applyPromocode(promocodeId, userId, 'order-2')
    ).rejects.toThrow('Промокод уже использован');
  });
  
  it('should validate minimum order amount', async () => {
    const result = await validatePromocode('TEST10', 'user-1', 500);
    expect(result.valid).toBe(false);
    expect(result.error).toContain('Минимальная сумма заказа');
  });
});

# 4. Добавить в package.json
"scripts": {
  "test": "vitest",
  "test:ui": "vitest --ui",
  "test:coverage": "vitest --coverage"
}
```

---

## ВЫСОКИЕ ПРИОРИТЕТЫ (1-2 недели)

### 7. Слабые требования к паролям

**Проблема:**
```typescript
passwordHash: z.string().min(8, "Пароль должен быть не менее 8 символов")
```
Нет проверки сложности, хотя функция `validatePasswordStrength` существует.

**Решение:**
```typescript
// В registerSchema и других местах
password: z
  .string()
  .min(8, "Пароль должен содержать минимум 8 символов")
  .refine(
    (password) => {
      const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
      return strongPasswordRegex.test(password);
    },
    "Пароль должен содержать заглавные и строчные буквы, цифры и спецсимволы"
  )
```

---

### 8. Отсутствие Session Regeneration при изменении прав

**Проблема:**
При добавлении/удалении ролей пользователя сессия не обновляется, что может привести к Session Fixation атакам.

**Решение:**
```typescript
// После изменения ролей
app.post("/api/admin/users/:userId/roles", requireRole(['admin']), async (req, res) => {
  const { role } = req.body;
  
  await storage.addUserRole({ userId: req.params.userId, role });
  
  // Если меняем роли текущего пользователя, обновляем сессию
  if (req.params.userId === req.session.userId) {
    const roles = await storage.getUserRoles(req.session.userId);
    
    req.session.regenerate((err) => {
      if (err) {
        return res.status(500).json({ message: "Ошибка обновления сессии" });
      }
      
      req.session.userId = req.params.userId;
      req.session.userRoles = roles.map(r => r.role);
      
      res.json({ message: "Роль добавлена" });
    });
  } else {
    res.json({ message: "Роль добавлена" });
  }
});
```

---

### 9. Отсутствие обработки Async ошибок

**Проблема:**
Express не ловит async ошибки автоматически.

**Решение:**
```bash
npm install express-async-errors
```

```typescript
// server/index.ts - в самом начале, перед другими импортами
import 'express-async-errors';
import express from 'express';
// ... остальные импорты
```

---

### 10. Отсутствие Pagination во всех запросах

**Проблема:**
```typescript
// server/storage.ts:160-162
async getUsers(): Promise<User[]> {
  return db.select().from(users).orderBy(desc(users.createdAt));
}
```
Загружает все записи без ограничения.

**Решение:**
```typescript
async getUsers(options?: {
  page?: number;
  limit?: number;
}): Promise<{ users: User[]; total: number; page: number; totalPages: number }> {
  const page = options?.page || 1;
  const limit = options?.limit || 50;
  const offset = (page - 1) * limit;
  
  const [users, totalResult] = await Promise.all([
    db
      .select()
      .from(users)
      .orderBy(desc(users.createdAt))
      .limit(limit)
      .offset(offset),
    db
      .select({ count: sql<number>`count(*)` })
      .from(users)
  ]);
  
  const total = Number(totalResult[0].count);
  const totalPages = Math.ceil(total / limit);
  
  return { users, total, page, totalPages };
}
```

---

### 11. Миграции БД вместо Push

**Проблема:**
Используется `drizzle-kit push` без версионированных миграций.

**Решение:**
```typescript
// 1. Изменить package.json
"scripts": {
  "db:generate": "drizzle-kit generate",
  "db:migrate": "tsx server/migrate.ts",
  "db:studio": "drizzle-kit studio"
}

// 2. Создать server/migrate.ts
import { drizzle } from 'drizzle-orm/neon-serverless';
import { migrate } from 'drizzle-orm/neon-serverless/migrator';
import { Pool } from '@neondatabase/serverless';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle(pool);

async function main() {
  console.log('Running migrations...');
  await migrate(db, { migrationsFolder: './drizzle' });
  console.log('Migrations completed!');
  process.exit(0);
}

main().catch((err) => {
  console.error('Migration failed!', err);
  process.exit(1);
});

// 3. Workflow изменений схемы:
// - Изменить shared/schema.ts
// - npm run db:generate (создаст SQL миграцию в drizzle/)
// - Проверить сгенерированную миграцию
// - npm run db:migrate (применить к БД)
```

---

### 12. Добавить Health Check endpoints

**Проблема:**
Отсутствуют endpoints для мониторинга состояния приложения.

**Решение:**
```typescript
// server/routes.ts
app.get('/health', async (req, res) => {
  try {
    // Проверка БД
    await db.execute(sql`SELECT 1`);
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: 'connected'
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      database: 'disconnected',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/health/ready', async (req, res) => {
  // Более детальная проверка готовности
  try {
    await db.execute(sql`SELECT 1`);
    // Можно добавить проверку других сервисов
    
    res.json({ ready: true });
  } catch (error) {
    res.status(503).json({ ready: false });
  }
});
```

---

## СРЕДНИЕ ПРИОРИТЕТЫ (месяц)

### 13. Рефакторинг routes.ts (1798 строк)

**Проблема:**
Монолитный файл с перемешанной бизнес-логикой.

**Решение:**
```typescript
// Структура:
// server/
//   ├── routes/
//   │   ├── auth.routes.ts
//   │   ├── products.routes.ts
//   │   ├── orders.routes.ts
//   │   ├── admin.routes.ts
//   │   └── support.routes.ts
//   ├── services/
//   │   ├── auth.service.ts
//   │   ├── order.service.ts
//   │   └── product.service.ts
//   ├── controllers/
//   │   ├── auth.controller.ts
//   │   └── order.controller.ts

// server/routes/auth.routes.ts
import { Router } from 'express';
import { AuthController } from '../controllers/auth.controller';

const router = Router();
const authController = new AuthController();

router.post('/register', registerLimiter, authController.register);
router.post('/login', authLimiter, authController.login);
router.post('/logout', authController.logout);

export default router;

// server/index.ts
import authRoutes from './routes/auth.routes';
import productRoutes from './routes/products.routes';

app.use('/api/auth', authRoutes);
app.use('/api/products', productRoutes);
```

---

### 14. Bundle Size анализ и оптимизация

**Проблема:**
Нет анализа размера bundle.

**Решение:**
```bash
npm install -D rollup-plugin-visualizer
```

```typescript
// vite.config.ts
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui-vendor': ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu'],
          'query-vendor': ['@tanstack/react-query'],
        }
      }
    }
  }
});

// package.json
"scripts": {
  "analyze": "vite build --mode analyze"
}
```

---

### 15. Responsive Images для мобильных устройств

**Проблема:**
Мобильные устройства загружают full-size изображения.

**Решение:**
```typescript
// server/ImagePipeline.ts - генерировать несколько размеров
async processImageWithSizes(
  buffer: Buffer,
  originalName: string
): Promise<{
  original: ProcessedImageResult;
  thumbnail: ProcessedImageResult;
  medium: ProcessedImageResult;
}> {
  const sizes = [
    { name: 'thumbnail', width: 300, height: 300 },
    { name: 'medium', width: 600, height: 600 },
    { name: 'original', width: 1200, height: 1200 }
  ];
  
  const results = await Promise.all(
    sizes.map(size => this.processImageWithSize(buffer, originalName, size))
  );
  
  return {
    thumbnail: results[0],
    medium: results[1],
    original: results[2]
  };
}

// client - использовать <picture>
<picture>
  <source media="(max-width: 640px)" srcSet={product.images[0].thumbnail} />
  <source media="(max-width: 1024px)" srcSet={product.images[0].medium} />
  <img src={product.images[0].original} alt={product.name} />
</picture>
```

---

### 16. HTTP Caching для статики

**Проблема:**
В production нет кеш-заголовков для статических файлов.

**Решение:**
```typescript
// server/index.ts
app.use('/uploads', express.static('uploads', {
  maxAge: env.NODE_ENV === 'production' ? '7d' : 0,
  etag: true,
  lastModified: true,
  setHeaders: (res, path) => {
    if (env.NODE_ENV === 'production') {
      res.setHeader('Cache-Control', 'public, max-age=604800, immutable');
    }
  }
}));

// Для Vite assets
if (env.NODE_ENV === 'production') {
  app.use(express.static('dist/public', {
    maxAge: '1y',
    immutable: true
  }));
}
```

---

### 17. API документация (OpenAPI/Swagger)

**Проблема:**
Отсутствует документация API.

**Решение:**
```bash
npm install swagger-ui-express swagger-jsdoc
```

```typescript
// server/swagger.ts
import swaggerJsdoc from 'swagger-jsdoc';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'ЭкоМаркет API',
      version: '1.0.0',
      description: 'E-commerce API для натуральных продуктов'
    },
    servers: [
      { url: 'http://localhost:5000', description: 'Development' },
      { url: 'https://api.ecomarket.ru', description: 'Production' }
    ]
  },
  apis: ['./server/routes/*.ts']
};

export const swaggerSpec = swaggerJsdoc(options);

// server/index.ts
import swaggerUi from 'swagger-ui-express';
import { swaggerSpec } from './swagger';

if (env.NODE_ENV === 'development') {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
}

// В route файлах добавить JSDoc
/**
 * @openapi
 * /api/products:
 *   get:
 *     summary: Получить список товаров
 *     parameters:
 *       - in: query
 *         name: categoryId
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Список товаров
 */
app.get('/api/products', async (req, res) => {
  // ...
});
```

---

## НИЗКИЕ ПРИОРИТЕТЫ (backlog)

### 18. Generic Repository Pattern

**Проблема:**
Дублирование CRUD операций в storage.ts.

**Решение:**
```typescript
// server/repositories/base.repository.ts
export abstract class BaseRepository<T, InsertT> {
  constructor(protected table: any) {}
  
  async findById(id: string): Promise<T | undefined> {
    const [result] = await db
      .select()
      .from(this.table)
      .where(eq(this.table.id, id))
      .limit(1);
    return result;
  }
  
  async findAll(options?: PaginationOptions): Promise<T[]> {
    const query = db.select().from(this.table);
    
    if (options?.limit) query.limit(options.limit);
    if (options?.offset) query.offset(options.offset);
    
    return query;
  }
  
  async create(data: InsertT): Promise<T> {
    const [result] = await db.insert(this.table).values(data).returning();
    return result;
  }
  
  async update(id: string, data: Partial<InsertT>): Promise<T | undefined> {
    const [result] = await db
      .update(this.table)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(this.table.id, id))
      .returning();
    return result;
  }
  
  async delete(id: string): Promise<void> {
    await db.delete(this.table).where(eq(this.table.id, id));
  }
}

// server/repositories/product.repository.ts
export class ProductRepository extends BaseRepository<Product, InsertProduct> {
  constructor() {
    super(products);
  }
  
  // Кастомные методы
  async findByCategory(categoryId: string): Promise<Product[]> {
    return db.select().from(products).where(eq(products.categoryId, categoryId));
  }
}
```

---

### 19. Error Reporting (Sentry)

**Проблема:**
Ошибки только логируются локально.

**Решение:**
```bash
npm install @sentry/node @sentry/react
```

```typescript
// server/index.ts
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: env.NODE_ENV,
  tracesSampleRate: 1.0,
});

app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

// После всех routes
app.use(Sentry.Handlers.errorHandler());

// client/src/main.tsx
import * as Sentry from '@sentry/react';

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  integrations: [new Sentry.BrowserTracing()],
  tracesSampleRate: 1.0,
});
```

---

### 20. Виртуализация длинных списков

**Проблема:**
Каталог рендерит все 30 товаров сразу.

**Решение:**
```bash
npm install @tanstack/react-virtual
```

```typescript
// client/src/components/ProductGrid.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

export function VirtualProductGrid({ products }: { products: Product[] }) {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const rowVirtualizer = useVirtualizer({
    count: Math.ceil(products.length / 3),
    getScrollElement: () => parentRef.current,
    estimateSize: () => 400,
    overscan: 2
  });
  
  return (
    <div ref={parentRef} className="h-screen overflow-auto">
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative'
        }}
      >
        {rowVirtualizer.getVirtualItems().map((virtualRow) => {
          const startIdx = virtualRow.index * 3;
          const rowProducts = products.slice(startIdx, startIdx + 3);
          
          return (
            <div
              key={virtualRow.key}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                transform: `translateY(${virtualRow.start}px)`
              }}
              className="grid grid-cols-3 gap-4"
            >
              {rowProducts.map(product => (
                <ProductCard key={product.id} product={product} />
              ))}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

---

### 21. Distributed Rate Limiting с Redis

**Проблема:**
При горизонтальном масштабировании каждый инстанс имеет свой лимит.

**Решение:**
```bash
npm install ioredis rate-limit-redis
```

```typescript
// server/middleware/rateLimiter.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redisClient = new Redis(process.env.REDIS_URL);

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  store: new RedisStore({
    client: redisClient,
    prefix: 'rl:auth:'
  }),
  message: 'Слишком много попыток входа'
});
```

---

## ИТОГО

**Критические (6 проблем):** Path traversal, race conditions, overselling, memory leak, encryption, тесты  
**Высокие (6 проблем):** Пароли, session security, async errors, pagination, миграции, health checks  
**Средние (5 проблем):** Рефакторинг, bundle size, images, caching, документация  
**Низкие (5 проблем):** Generic repository, Sentry, виртуализация, Redis, distributed systems

**Рекомендуемый порядок внедрения:**
1. Неделя 1: Критические #1-3 (безопасность файлов и промокодов)
2. Неделя 2: Критические #4-6 (memory leak, encryption, тесты)
3. Неделя 3-4: Высокие приоритеты
4. Месяц 2: Средние приоритеты
5. Backlog: Низкие приоритеты по мере необходимости
