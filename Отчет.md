# Отчет об аудите бэкенд кода после перехода с сессий на JWT

**Дата:** 01.12.2025  
**Проект:** EcoMarket REST API  
**Статус:** Критические проблемы обнаружены

---

## Резюме

После перехода с сессий на JWT обнаружена **критическая архитектурная проблема**: в коде одновременно используются **две независимые системы аутентификации** (JWT и сессии), что создает серьезные уязвимости безопасности, избыточность и несогласованность данных. Обнаружено **15 критических проблем** и **8 проблем средней серьезности**.

---

## 1. КРИТИЧЕСКАЯ ПРОБЛЕМА: Гибридная архитектура аутентификации (JWT + Сессии)

### Анализ проблемы

**Что обнаружено:**
- JWT используется для HTTP API аутентификации (`authenticateToken` middleware)
- Express-session используется для WebSocket аутентификации
- CSRF защита требует активную сессию
- Два параллельных механизма хранения состояния пользователя

**Файлы с проблемой:**
- `server/auth.ts` - использует JWT cookies (`accessToken`, `refreshToken`)
- `server/routes.ts` (строки 32-93) - WebSocket требует сессии
- `server/middleware/csrf.ts` (строки 13-27) - CSRF требует sessionID
- `server/session.ts` - настроена таблица PostgreSQL для сессий
- `server/middleware/sessionRefresh.ts` - обновляет сессии

**Риски:**
1. **Рассинхронизация данных**: JWT может быть валидным, но сессия истекла (или наоборот)
2. **Уязвимость безопасности**: Если JWT отозван (через `tokenVersion`), но сессия активна, пользователь может использовать WebSocket
3. **Избыточность ресурсов**: Двойное хранение в PostgreSQL (сессии + refresh tokens)
4. **Путаница в логике**: Logout должен очищать и JWT, и сессию

**Примеры рассинхронизации:**
```typescript
// Сценарий 1: Пользователь меняет пароль
// ✅ JWT: tokenVersion++, все refresh tokens удалены
// ❌ Сессия: Остается активной в БД! WebSocket работает!

// Сценарий 2: Админ банит пользователя
// ✅ JWT: Проверка banned флага в authenticateToken
// ❌ Сессия: WebSocket не проверяет banned флаг!
```

### Как это решают популярные сайты

**Stripe** (платежи с высокими требованиями к безопасности):
- **100% JWT** для API
- WebSocket также использует JWT через query параметр: `wss://api.stripe.com?auth=jwt_token`
- CSRF не нужен при правильной конфигурации JWT (httpOnly + SameSite=strict)

**GitHub** (2FA, WebSocket для notifications):
- JWT токены для API
- WebSocket аутентификация через **тот же JWT**, переданный в заголовке при установке соединения
- CSRF tokens только для небезопасных legacy endpoints

**Slack** (real-time messaging):
- Все коммуникации (HTTP + WebSocket) используют JWT
- Refresh tokens для длительных сессий
- Никаких серверных сессий

### Рекомендуемое решение

**Вариант A: Полный переход на JWT (рекомендуется)**

```typescript
// 1. WebSocket аутентификация через JWT
wss.on("connection", async (ws, req) => {
  const token = extractTokenFromCookie(req.headers.cookie);
  const payload = verifyAccessToken(token); // Та же проверка что и в HTTP
  
  const userStatus = await getUserStatus(payload.userId);
  if (payload.v < userStatus.tokenVersion) {
    ws.close(1008, 'Token revoked');
    return;
  }
  
  connectedUsers.set(payload.userId, { ws, roles: payload.roles });
});

// 2. Убрать CSRF или использовать Double Submit Cookies без сессий
// https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie
```

**Преимущества:**
- ✅ Единая система аутентификации
- ✅ Stateless архитектура (легко масштабировать)
- ✅ Нет рассинхронизации
- ✅ Меньше нагрузка на PostgreSQL

**Вариант B: Полный откат на сессии (не рекомендуется)**
- Вернуться к passport.js с сессиями
- Использовать `req.session.userId` везде
- Отказаться от JWT

---

## 2. CSRF защита несовместима с JWT архитектурой

### Анализ проблемы

**Файл:** `server/middleware/csrf.ts`

**Проблемы:**
```typescript
getSessionIdentifier: (req: Request) => {
  const sessionId = req.sessionID || req.session?.id;
  if (!sessionId) {
    throw new Error('Session required for CSRF protection');
  }
  return sessionId;
}
```

1. CSRF middleware **требует активную сессию**
2. Но routes используют JWT, не сессии
3. В `/api/auth/login` и `/api/auth/register` CSRF **пропускается** (строки 54-57), но сессия не создается
4. Следующий запрос после login **упадет с ошибкой** если нет сессии

**Тестовый сценарий краха:**
```bash
# 1. Пользователь логинится
POST /api/auth/login  # OK (CSRF skipped)
# Получает JWT cookies, но сессия НЕ создана

# 2. Пользователь делает POST запрос
POST /api/cart  # ❌ FAIL: "Session required for CSRF protection"
```

### Как это решают популярные сайты

**Auth0** (аутентификация для 10+ миллионов приложений):
- Для JWT используют **SameSite=Strict cookies** вместо CSRF tokens
- CSRF tokens используются только для session-based auth

**Firebase Authentication**:
- JWT в httpOnly cookies
- CSRF не используется вообще
- Защита через `SameSite=Strict` + `Secure` флаги

**AWS Cognito**:
- JWT access tokens
- CSRF не требуется для stateless API

### Рекомендуемое решение

**Опция 1: Убрать CSRF для JWT endpoints (рекомендуется)**
```typescript
// Все JWT-based routes НЕ нуждаются в CSRF при условии:
// 1. httpOnly: true
// 2. sameSite: 'strict'
// 3. secure: true (в продакшене)

export function csrfMiddleware(req: Request, res: Response, next: NextFunction): void {
  // Skip CSRF for all JWT-authenticated routes
  if (req.path.startsWith('/api/')) {
    return next(); // JWT cookies с SameSite=strict достаточно
  }
  // ... остальная логика для legacy endpoints
}
```

**Опция 2: Double Submit Cookie Pattern (без сессий)**
```typescript
// Использовать CSRF токен в cookie + header
// БЕЗ привязки к серверной сессии
// https://github.com/pillarjs/understanding-csrf
```

---

## 3. Logout не инвалидирует сессии

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строки 180-200)

```typescript
router.post("/logout", authenticateToken, async (req, res) => {
  // ✅ Удаляет refresh token из БД
  await storage.deleteRefreshToken(payload.jti);
  
  // ✅ Чистит JWT cookies
  res.clearCookie('accessToken', { path: '/' });
  res.clearCookie('refreshToken', { path: '/api/auth/refresh' });
  
  // ❌ НЕ удаляет сессию из PostgreSQL!
  // ❌ WebSocket соединение остается активным!
  
  res.json({ message: "Выход выполнен" });
});
```

**Последствия:**
- Пользователь "вышел" через HTTP API
- Но WebSocket соединение **продолжает работать** (использует старую сессию)
- Админ не может "выгнать" пользователя из чата

### Как это решают популярные сайты

**Discord** (миллионы concurrent WebSocket connections):
- Logout инвалидирует **все активные соединения** пользователя
- Сервер отправляет `CLOSE_CONNECTION` event во все WebSocket
- Клиент получает уведомление и закрывает соединение

**WhatsApp Web**:
- При logout из мобильного приложения
- Web версия **моментально отключается** (WebSocket закрывается)

### Рекомендуемое решение

```typescript
router.post("/logout", authenticateToken, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  if (refreshToken) {
    const payload = verifyRefreshToken(refreshToken);
    await storage.deleteRefreshToken(payload.jti);
  }
  
  // ДОБАВИТЬ: Закрыть все WebSocket соединения пользователя
  const connection = connectedUsers.get(req.userId!);
  if (connection) {
    connection.ws.close(1000, 'User logged out');
    connectedUsers.delete(req.userId!);
  }
  
  // ДОБАВИТЬ: Инвалидировать все сессии (если используются)
  await invalidateAllUserSessions(req.userId!);
  
  res.clearCookie('accessToken', { path: '/' });
  res.clearCookie('refreshToken', { path: '/api/auth/refresh' });
  res.clearCookie('sessionId'); // ДОБАВИТЬ
  
  res.json({ message: "Выход выполнен" });
});
```

---

## 4. WebSocket аутентификация использует устаревшие сессии

### Анализ проблемы

**Файл:** `server/routes.ts` (строки 32-93)

```typescript
async function validateSessionFromCookie(cookieHeader: string | undefined) {
  // Парсит sessionId cookie
  // Достает сессию из PostgreSQL
  const sessionRecord = await db.query.sessions.findFirst({ ... });
  
  // ❌ НЕ проверяет tokenVersion!
  // ❌ НЕ проверяет banned флаг!
  // ❌ НЕ проверяет deletedAt!
  
  return { userId: sessionData.userId, userRoles: sessionData.userRoles };
}
```

**Критическая уязвимость:**
1. Админ банит пользователя → `banned: true` в БД
2. HTTP API блокирует доступ ✅ (проверка в `authenticateToken`)
3. Но WebSocket **продолжает работать** ❌

### Рекомендуемое решение

```typescript
async function validateSessionFromCookie(cookieHeader: string | undefined) {
  // ... извлечь sessionId ...
  
  const sessionRecord = await db.query.sessions.findFirst({ ... });
  if (!sessionRecord) return null;
  
  const userId = sessionRecord.sess.userId;
  
  // ДОБАВИТЬ: Проверки как в authenticateToken
  const user = await storage.getUser(userId);
  if (!user) return null;
  if (user.banned) return null;
  if (user.deletedAt) return null;
  
  // ДОБАВИТЬ: Проверка tokenVersion если используем гибрид
  const sessionTokenVersion = sessionRecord.sess.tokenVersion || 1;
  if (sessionTokenVersion < user.tokenVersion) {
    // Сессия устарела после смены пароля
    return null;
  }
  
  return { userId, userRoles: sessionRecord.sess.userRoles };
}
```

---

## 5. SameSite конфликт между JWT cookies и CSRF cookie

### Анализ проблемы

**JWT cookies** (`server/routes/auth.routes.ts` строка 70):
```typescript
res.cookie('accessToken', accessToken, {
  sameSite: 'strict', // Всегда strict
});
```

**CSRF cookie** (`server/middleware/csrf.ts` строка 35):
```typescript
cookieOptions: {
  sameSite: env.NODE_ENV === 'production' ? 'strict' : 'lax',
}
```

**Session cookie** (`server/session.ts` строка 26):
```typescript
cookie: {
  sameSite: env.NODE_ENV === 'production' ? 'strict' : 'lax',
}
```

**Проблема:** Несогласованность конфигурации

**Последствия в development:**
- Если CSRF cookie `lax`, но accessToken `strict`
- Cross-site POST запросы могут не работать корректно

### Как это решают популярные сайты

**Google Workspace**:
- Все auth cookies имеют **одинаковую конфигурацию**
- `SameSite=None; Secure` для cross-domain SSO
- Или `SameSite=Strict` для single-domain

**Microsoft Azure**:
- Unified cookie policy для всех auth cookies
- Единый middleware для установки всех cookies

### Рекомендуемое решение

```typescript
// server/utils/cookieConfig.ts
export const AUTH_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: env.NODE_ENV === 'production',
  sameSite: env.NODE_ENV === 'production' ? 'strict' : 'lax',
  path: '/',
} as const;

// Использовать везде
res.cookie('accessToken', token, {
  ...AUTH_COOKIE_OPTIONS,
  maxAge: 15 * 60 * 1000,
});
```

---

## 6. Refresh token rotation может вызвать race conditions

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строки 232-244)

```typescript
// Удаляем старый refresh token
await storage.deleteRefreshToken(payload.jti);

// Создаем новый refresh token
await storage.createRefreshToken({ ... });
```

**Проблема:**
Если два параллельных запроса `/api/auth/refresh` придут одновременно:

```
Запрос A                        Запрос B
├─ Валидирует old_token ✅     ├─ Валидирует old_token ✅
├─ Удаляет old_token           ├─ Удаляет old_token
├─ Создает new_token_A         ├─ Создает new_token_B
└─ Возвращает new_token_A      └─ Возвращает new_token_B

Результат: У пользователя ДВА активных refresh token!
```

### Как это решают популярные сайты

**Auth0**:
- Использует **токен family** с `jti` цепочкой
- Если обнаружен reuse старого refresh token → **инвалидирует всю семью** (защита от token theft)

**Okta**:
- Refresh endpoint использует **database-level locking**
- `SELECT ... FOR UPDATE` на строку refresh token

**Firebase**:
- Идемпотентность: повторный refresh с тем же токеном возвращает тот же результат

### Рекомендуемое решение

**Опция 1: Database transaction + FOR UPDATE**
```typescript
router.post("/refresh", async (req, res) => {
  await db.transaction(async (tx) => {
    const tokenRecord = await tx
      .select()
      .from(refreshTokens)
      .where(eq(refreshTokens.jti, payload.jti))
      .for('update') // Блокировка строки
      .limit(1);
    
    if (!tokenRecord[0]) {
      // Токен уже использован - возможна кража!
      await tx.delete(refreshTokens).where(eq(refreshTokens.userId, payload.userId));
      throw new Error('Token reuse detected');
    }
    
    // Удалить + создать в одной транзакции
    await tx.delete(refreshTokens).where(eq(refreshTokens.jti, payload.jti));
    await tx.insert(refreshTokens).values({ ... });
  });
});
```

**Опция 2: Идемпотентность (проще)**
```typescript
// Кэшировать результат refresh на 5 секунд
const refreshCache = new Map();

router.post("/refresh", async (req, res) => {
  const cached = refreshCache.get(payload.jti);
  if (cached && Date.now() - cached.timestamp < 5000) {
    return res.json(cached.result); // Возврат кэшированного результата
  }
  
  // ... обычная логика ...
  
  refreshCache.set(payload.jti, { result, timestamp: Date.now() });
});
```

---

## 7. Access token не может быть отозван до истечения срока

### Анализ проблемы

JWT access tokens живут **15 минут**. Если access token украден, его нельзя отозвать досрочно (stateless природа JWT).

**Сценарий:**
1. Админ банит пользователя → `banned: true`
2. `authenticateToken` middleware проверяет `banned` флаг ✅
3. НО: проверка делается **на каждый запрос** (запрос к БД!)
4. При высокой нагрузке это **медленно** (даже с кэшем 10 минут)

**Файл:** `server/auth.ts` (строка 54-74)
```typescript
const userStatus = await getUserStatus(payload.userId); // DB query (кэш 10 мин)

if (payload.v < userStatus.tokenVersion) { ... }
if (userStatus.banned) { ... }
if (userStatus.deletedAt) { ... }
```

### Как это решают популярные сайты

**Google Cloud Platform**:
- Access tokens короткие (1 час)
- Refresh tokens долгие
- Критические операции требуют **re-authentication**

**Cloudflare**:
- Используют короткие access tokens (5 минут)
- Автоматический refresh в фоне

**AWS**:
- Access tokens 1 час
- Revocation через STS (managed service)
- Для критичных операций - MFA challenge

### Рекомендуемое решение

**Опция 1: Короткие access tokens**
```typescript
export function generateAccessToken(...) {
  return jwt.sign(
    { userId, roles, v: tokenVersion },
    env.JWT_SECRET,
    { expiresIn: '5m' } // 15m → 5m
  );
}
```

**Опция 2: Redis blacklist для критичных случаев**
```typescript
// Добавить в Redis при бане
await redis.set(`revoked_user:${userId}`, '1', 'EX', 900); // 15 минут

// Проверять в middleware
const isRevoked = await redis.get(`revoked_user:${userId}`);
if (isRevoked) { ... }
```

**Опция 3: JTI blacklist (как у refresh tokens)**
```typescript
// Каждый access token имеет уникальный jti
// При бане - добавить все активные JTI в blacklist
```

---

## 8. RefreshToken path restriction небезопасна

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строка 80, 155, 258)

```typescript
res.cookie('refreshToken', refreshToken, {
  path: '/api/auth/refresh', // Ограничен одним путем
});
```

**Проблема:**
1. Браузер **НЕ отправит** этот cookie на другие пути (например `/api/auth/logout`)
2. В logout endpoint: `const refreshToken = req.cookies.refreshToken;` вернет `undefined`
3. Refresh token **не будет удален** при logout

**Тест:**
```bash
# После login
curl -b cookies.txt /api/auth/logout
# refreshToken cookie НЕ отправляется (path mismatch)
# Token остается в БД!
```

### Как это решают популярные сайты

**GitHub**:
- Refresh token доступен на всех auth endpoints: `path: '/api/auth'`

**Spotify**:
- Refresh token: `path: '/'` (доступен везде)
- Безопасность через `httpOnly + sameSite=strict`

### Рекомендуемое решение

```typescript
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,
  secure: env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000,
  path: '/api/auth', // Не '/api/auth/refresh', а '/api/auth'
});
```

---

## 9. Password change не инвалидирует активные access tokens

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строки 403-413)

```typescript
router.put("/password", async (req, res) => {
  // ✅ Увеличивает tokenVersion
  const newVersion = await storage.incrementTokenVersion(req.userId!);
  
  // ✅ Удаляет все refresh tokens
  await storage.deleteAllRefreshTokens(req.userId!);
  
  // ✅ Создает новый access + refresh token для текущей сессии
  const accessToken = generateAccessToken(req.userId!, roles, newVersion);
  
  // ❌ Но старые access tokens (v=1) будут работать еще 15 минут!
});
```

**Проблема:**
- Если токен украден ДО смены пароля
- Злоумышленник может использовать его **еще 15 минут**
- `authenticateToken` проверяет `payload.v < userStatus.tokenVersion`, но это **async запрос** с кэшем 10 минут

### Как это решают популярные сайты

**Facebook**:
- При смене пароля **немедленно** инвалидируются все сессии
- Пользователь должен войти заново на всех устройствах

**Amazon**:
- "Logout on all devices" опция
- Immediate revocation всех токенов

### Рекомендуемое решение

**Опция 1: Очистить кэш**
```typescript
invalidateUserCache(req.userId!); // Уже есть!

// НО: кэш только в памяти одного процесса
// Если несколько серверов - нужен Redis
```

**Опция 2: WebSocket broadcast**
```typescript
// Отправить событие всем активным соединениям пользователя
const connection = connectedUsers.get(req.userId!);
if (connection) {
  connection.ws.send(JSON.stringify({
    type: 'force_logout',
    reason: 'password_changed'
  }));
}
```

**Опция 3: Короткие access tokens (5 минут)**
```typescript
// Максимальное окно уязвимости = 5 минут
{ expiresIn: '5m' }
```

---

## 10. Отсутствует проверка на concurrent logout

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строка 182)

```typescript
router.post("/logout", authenticateToken, async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  if (refreshToken) {
    try {
      const payload = verifyRefreshToken(refreshToken);
      await storage.deleteRefreshToken(payload.jti);
    } catch (error) {
      logger.warn('Invalid refresh token during logout', { error });
      // ⚠️ Ошибка игнорируется, продолжается выполнение
    }
  }
```

**Проблема:**
- Если refresh token **уже использован** (например, параллельный logout)
- `verifyRefreshToken` выбросит ошибку (JWT expired или не найден в БД)
- Logout продолжится, но cookie **НЕ будут очищены** (из-за раннего return в catch)

### Рекомендуемое решение

```typescript
router.post("/logout", authenticateToken, async (req, res) => {
  try {
    const refreshToken = req.cookies.refreshToken;
    if (refreshToken) {
      try {
        const payload = verifyRefreshToken(refreshToken);
        await storage.deleteRefreshToken(payload.jti);
      } catch (error) {
        // Игнорировать ошибки валидации, но продолжить logout
        logger.warn('Refresh token invalid during logout (expected)', { error });
      }
    }
    
    // ВСЕГДА очищать cookies, даже если refresh token невалидный
    res.clearCookie('accessToken', { path: '/' });
    res.clearCookie('refreshToken', { path: '/api/auth' });
    res.clearCookie('sessionId');
    res.clearCookie('csrf-token');
    
    invalidateUserCache(req.userId!);
    
    res.json({ message: "Выход выполнен" });
  } catch (error) {
    logger.error('Logout error', { error });
    
    // Даже при ошибке - попытаться очистить cookies
    res.clearCookie('accessToken', { path: '/' });
    res.clearCookie('refreshToken', { path: '/api/auth' });
    
    res.status(500).json({ message: "Ошибка выхода" });
  }
});
```

---

## 11. Отсутствует rate limiting на /refresh endpoint

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строка 202)

```typescript
router.post("/refresh", async (req, res) => {
  // ❌ НЕТ rate limiter!
});
```

**В то время как:**
```typescript
router.post("/login", authLimiter, async (req, res) => { ... }); // ✅ 15 req/15min
router.post("/register", registerLimiter, async (req, res) => { ... }); // ✅ 5 req/hour
```

**Уязвимость:**
- Злоумышленник может делать **неограниченное количество** refresh запросов
- Brute-force refresh tokens
- DDoS атака на БД (каждый refresh = 3-4 DB queries)

### Как это решают популярные сайты

**Auth0**:
- Refresh endpoint: max 10 requests per minute per IP
- После превышения - temporary ban

**Okta**:
- Rate limit per user: 5 refresh/minute
- Per IP: 100 refresh/minute

### Рекомендуемое решение

```typescript
// server/middleware/rateLimiter.ts
export const refreshLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 минута
  max: 10, // 10 запросов
  message: 'Слишком много попыток обновления токена',
  standardHeaders: true,
  legacyHeaders: false,
  // Использовать userId из refresh token (не IP)
  keyGenerator: (req) => {
    try {
      const token = req.cookies.refreshToken;
      const payload = verifyRefreshToken(token);
      return `refresh:${payload.userId}`;
    } catch {
      return req.ip || 'unknown';
    }
  }
});

// server/routes/auth.routes.ts
router.post("/refresh", refreshLimiter, async (req, res) => {
  // ...
});
```

---

## 12. Refresh token не имеет rotation policy

### Анализ проблемы

**Файл:** `server/routes/auth.routes.ts` (строка 234)

```typescript
// При refresh
await storage.deleteRefreshToken(payload.jti); // Старый удален
await storage.createRefreshToken({ jti: newJti, ... }); // Новый создан
```

**Проблема: Нет защиты от replay attacks**

Если refresh token перехвачен:
1. Злоумышленник использует его → получает новый
2. Легитимный пользователь **тоже** пытается использовать старый → 401 error
3. **НЕТ механизма обнаружения** этой ситуации

### Как это решают популярные сайты

**Auth0 - Refresh Token Rotation with Reuse Detection**:
```
User                    Attacker
├─ Refresh (jti=1)     
│  ├─ new jti=2 ✅     
│                      ├─ Refresh (jti=1) ❌ ОБНАРУЖЕНО!
│                      │  └─ Инвалидировать ВСЮ цепочку jti=1,2,3...
│  ├─ Refresh (jti=2)
│  │  └─ new jti=3 ✅
```

**Решение через token family**:
```typescript
export const refreshTokens = pgTable("refresh_tokens", {
  jti: varchar("jti").notNull().unique(),
  familyId: varchar("family_id").notNull(), // ДОБАВИТЬ
  parentJti: varchar("parent_jti"), // ДОБАВИТЬ
  // ...
});

// При refresh
const oldToken = await storage.getRefreshToken(payload.jti);

if (!oldToken) {
  // Попытка использовать уже использованный токен!
  // Найти всю семью и инвалидировать
  await storage.invalidateTokenFamily(payload.jti);
  throw new Error('Token reuse detected - possible attack');
}

// Создать новый токен в той же семье
await storage.createRefreshToken({
  familyId: oldToken.familyId,
  parentJti: payload.jti,
  // ...
});
```

---

## 13. User ban не закрывает активные WebSocket соединения

### Анализ проблемы

**Файл:** `server/routes/admin.routes.ts` (строки 64-80)

```typescript
router.post("/users/:userId/ban", async (req, res) => {
  await storage.updateUser(userId, { banned: true });
  await storage.incrementTokenVersion(userId);
  await storage.deleteAllRefreshTokens(userId);
  invalidateUserCache(userId);
  
  // ❌ WebSocket соединение продолжает работать!
  
  res.json({ success: true, message: "Пользователь заблокирован" });
});
```

**Последствия:**
- Забаненный пользователь **может продолжать** отправлять сообщения в поддержку
- WebSocket проверяет banned флаг только **при подключении**, не после

### Рекомендуемое решение

```typescript
// server/routes/admin.routes.ts
import { connectedUsers } from './routes'; // Экспортировать из routes.ts

router.post("/users/:userId/ban", async (req, res) => {
  const { userId } = req.params;
  
  await storage.updateUser(userId, { banned: true });
  await storage.incrementTokenVersion(userId);
  await storage.deleteAllRefreshTokens(userId);
  invalidateUserCache(userId);
  
  // ДОБАВИТЬ: Закрыть WebSocket
  const connection = connectedUsers.get(userId);
  if (connection) {
    connection.ws.close(1008, 'Account banned');
    connectedUsers.delete(userId);
  }
  
  res.json({ success: true, message: "Пользователь заблокирован" });
});
```

---

## 14. Отсутствует механизм обнаружения украденных токенов

### Анализ проблемы

Если refresh token украден, система **не может обнаружить** это до тех пор, пока:
1. Злоумышленник не попытается использовать его
2. Легитимный пользователь **тоже** не попытается (race condition)

**Текущая реализация:**
```typescript
// Нет логирования использования refresh tokens
// Нет fingerprinting устройств
// Нет аномалий detection
```

### Как это решают популярные сайты

**GitHub**:
- Логирует User-Agent + IP для каждого refresh
- Отправляет email alert если детектирован новый device/location

**Google**:
- Device fingerprinting
- "Was this you?" notifications
- Автоматический logout с подозрительных устройств

**Amazon**:
- Email alert при входе с нового устройства
- Требует дополнительную верификацию (OTP) при подозрительной активности

### Рекомендуемое решение

```typescript
// При refresh
router.post("/refresh", async (req, res) => {
  const payload = verifyRefreshToken(refreshToken);
  const storedToken = await storage.getRefreshToken(payload.jti);
  
  // ДОБАВИТЬ: Проверка User-Agent и IP
  const currentUserAgent = req.get('user-agent');
  const currentIP = req.ip;
  
  if (storedToken.userAgent !== currentUserAgent) {
    logger.warn('Refresh token used from different User-Agent', {
      userId: payload.userId,
      storedUA: storedToken.userAgent,
      currentUA: currentUserAgent,
      storedIP: storedToken.ipAddress,
      currentIP
    });
    
    // Опционально: отправить email пользователю
    await sendSecurityAlert(payload.userId, {
      type: 'suspicious_refresh',
      details: { newDevice: currentUserAgent, newIP: currentIP }
    });
  }
  
  // ... rest of refresh logic
});
```

---

## 15. Session table не очищается от expired сессий

### Анализ проблемы

**Файл:** `server/session.ts`

Используется `connect-pg-simple` для хранения сессий в PostgreSQL.

**Проблема:**
```typescript
store: new PgSession({
  pool,
  tableName: 'session',
  createTableIfMissing: true,
  disableTouch: false,
  // ❌ НЕТ pruneSessionInterval!
})
```

**Последствия:**
- Expired сессии **не удаляются** автоматически
- Таблица `session` **растет бесконечно**
- Снижается производительность WebSocket валидации

### Как это решают популярные сайты

**Express (официальная документация)**:
```javascript
new PgSession({
  pruneSessionInterval: 60 * 15, // 15 минут
})
```

**Redis Sessions (альтернатива)**:
- Автоматически удаляет expired ключи через TTL

### Рекомендуемое решение

**Опция 1: Автоматическая очистка**
```typescript
export const sessionMiddleware = session({
  store: new PgSession({
    pool,
    tableName: 'session',
    createTableIfMissing: true,
    disableTouch: false,
    pruneSessionInterval: 60 * 15, // Очистка каждые 15 минут
  }),
  // ...
});
```

**Опция 2: Cron job**
```typescript
// server/scheduler.ts
setInterval(async () => {
  const deleted = await db.execute(
    sql`DELETE FROM session WHERE expire < NOW()`
  );
  logger.info('Cleaned expired sessions', { count: deleted.rowCount });
}, 60 * 60 * 1000); // Каждый час
```

---

## Проблемы средней серьезности

### 16. Отсутствует CORS preflight caching

**Файл:** `server/middleware/cors.ts` (строка 52)

```typescript
maxAge: 86400, // 24 часа
```

**Проблема:** Это хорошо, но можно увеличить до 7 дней (максимум по спецификации)

**Решение:**
```typescript
maxAge: 604800, // 7 дней = меньше preflight requests
```

---

### 17. Hardcoded cookie path в clearCookie

**Файл:** `server/routes/auth.routes.ts`

```typescript
res.clearCookie('refreshToken', { path: '/api/auth/refresh' });
```

**Проблема:** Path дублируется в нескольких местах (DRY violation)

**Решение:**
```typescript
// server/config/cookies.ts
export const COOKIE_CONFIG = {
  refreshToken: { path: '/api/auth' },
  accessToken: { path: '/' },
} as const;
```

---

### 18. Отсутствует Content Security Policy для cookies

**Файл:** `server/index.ts`

Helmet CSP настроен, но не включает cookie directives.

**Рекомендация:**
```typescript
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      // ... existing ...
      'cookie': ["'self'", "'strict-dynamic'"],
    }
  }
}));
```

---

### 19. Refresh token userAgent не normalized

**Файл:** `server/routes/auth.routes.ts` (строка 63)

```typescript
userAgent: req.get('user-agent') || null,
```

**Проблема:** User-Agent может быть очень длинным (>1000 chars), хранится весь

**Решение:**
```typescript
function normalizeUserAgent(ua: string | undefined): string | null {
  if (!ua) return null;
  // Обрезать до 255 символов
  return ua.substring(0, 255);
}
```

---

### 20. Нет rate limiting на WebSocket connections per user

**Файл:** `server/routes.ts` (строка 155)

Есть rate limiting per IP, но нет per user.

**Проблема:** Пользователь может открыть 100 вкладок → 100 WebSocket соединений

**Решение:**
```typescript
const MAX_CONNECTIONS_PER_USER = 5;
const userConnections = new Map<string, Set<WebSocket>>();

wss.on("connection", async (ws, req) => {
  const sessionData = await validateSessionFromCookie(...);
  const userId = sessionData.userId;
  
  const connections = userConnections.get(userId) || new Set();
  if (connections.size >= MAX_CONNECTIONS_PER_USER) {
    ws.close(1008, 'Too many connections for this user');
    return;
  }
  
  connections.add(ws);
  userConnections.set(userId, connections);
});
```

---

### 21. JWT secret rotation не реализована

**Файл:** `server/env.ts`

```typescript
JWT_SECRET: z.string().min(32),
JWT_REFRESH_SECRET: z.string().min(32),
```

**Проблема:** Secrets никогда не меняются (best practice - rotate раз в 90 дней)

**Решение:**
```typescript
// Поддержка нескольких секретов
JWT_SECRETS: z.array(z.string().min(32)), // [current, previous, ...]

// При верификации пробовать все
function verifyAccessToken(token: string): AccessTokenPayload {
  for (const secret of env.JWT_SECRETS) {
    try {
      return jwt.verify(token, secret) as AccessTokenPayload;
    } catch {}
  }
  throw new Error('Invalid token');
}
```

---

### 22. Нет graceful shutdown для WebSocket

**Файл:** `server/index.ts` (строка 145-184)

Graceful shutdown есть для HTTP server, но WebSocket **не закрывается корректно**

**Решение:**
```typescript
const gracefulShutdown = async (signal: string) => {
  // ... existing code ...
  
  // ДОБАВИТЬ: Закрыть все WebSocket соединения
  wss.clients.forEach((ws) => {
    ws.close(1001, 'Server shutting down');
  });
  
  // Подождать закрытия соединений
  await new Promise((resolve) => {
    wss.close(resolve);
  });
  
  // ... остальной shutdown ...
};
```

---

### 23. Отсутствует monitoring метрики для аутентификации

**Нет tracking:**
- Сколько active refresh tokens в БД
- Сколько failed login attempts
- Среднее время жизни refresh token
- Rate limit hits

**Рекомендация:**
```typescript
// Экспортировать метрики для Prometheus
app.get('/metrics', async (req, res) => {
  const metrics = {
    active_refresh_tokens: await storage.countActiveRefreshTokens(),
    failed_logins_last_hour: await getFailedLoginsCount(),
    avg_refresh_token_age: await getAvgRefreshTokenAge(),
  };
  res.json(metrics);
});
```

---

## Итоговые рекомендации

### Приоритет 1 (Критично, сделать немедленно):

1. **Выбрать единую систему аутентификации** (рекомендую JWT everywhere)
2. **Убрать CSRF для JWT endpoints** или использовать Double Submit без сессий
3. **Исправить logout** - закрывать WebSocket + инвалидировать сессии
4. **Добавить rate limiting на /refresh**
5. **Исправить WebSocket validation** - проверять banned/deleted/tokenVersion

### Приоритет 2 (Важно, сделать в ближайшее время):

6. **Refresh token rotation с reuse detection**
7. **Короткие access tokens (5 минут)**
8. **Очистка expired sessions**
9. **Фикс refreshToken cookie path**
10. **Admin ban → закрытие WebSocket**

### Приоритет 3 (Желательно):

11. Device fingerprinting и security alerts
12. JWT secret rotation
13. Graceful shutdown для WebSocket
14. Monitoring метрики
15. Нормализация User-Agent

---

## Заключение

Основная проблема - **архитектурная несогласованность** между JWT и сессиями. Необходимо выбрать одну систему и последовательно применять её везде. Рекомендуется **полный переход на JWT** с отказом от серверных сессий для лучшей масштабируемости и простоты.

**Общая оценка безопасности текущей системы:** ⚠️ **Средний риск**

**Время на исправление критических проблем:** ~40-60 часов разработки
